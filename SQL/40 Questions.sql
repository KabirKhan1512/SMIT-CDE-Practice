use BikeStores

-- Q1: Create a view that returns each product’s total sold quantity and average discount received.
create view production.product_quantity_solds
as
	select p.product_name, sum(o.quantity) as total_quantity_sold, avg(o.discount) as avg_discount 
	from production.products p
	left join sales.order_items o
	on p.product_id = o.product_id
	group by p.product_name;

select * from production.product_quantity_solds
order by total_quantity_sold;

-- Q2: List customers who have placed more orders than the average number of orders per customer.
select * from sales.customer_orders
where total_price > (select avg(total_price) from sales.customer_orders)
order by total_price desc;

-- Q3: Build an IF…ELSE block that accepts @BrandID and prints the number of products under that brand, or “Brand not found” if none exist.
create procedure production.brand_check @brandID int
as
begin
if exists (select 1 from production.brands where brand_id = @brandID)
begin
		select b.brand_name, COUNT(p.product_id)
		from production.products p
		join production.brands b
		on p.brand_id = b.brand_id
		where b.brand_id = @brandID
		group by b.brand_name
End
else
begin
	print 'Brand ID not found.'
end
end;

exec production.brand_check @brandID = 112;


select * from production.brands;
select * from production.products;

-- Q4: Find all pairs of products that share the same brand but belong to different categories; show both product names, their categories, and the brand name.
select p.product_name, c.category_name, b.brand_name 
from production.categories c
join production.products p
on c.category_id = p.category_id
join production.brands b
on p.brand_id = b.brand_id
order by b.brand_id;

-- Q5: Write a scalar UDF ufn_CalcOrderTotal(@OrderID) returning the total amount (after discount) for that order.
create function sales.ufn_CalcOrderTotal (@orderID int)
returns Decimal(10,2) as
begin
	Declare @total Decimal (10,2)
	select @total = sum(quantity * (list_price -(list_price*discount)))
	from sales.order_items
	where order_id = @orderID
	Return ISNULL(@total, 0)
End;


select sales.ufn_calcordertotal(1) as total_order

-- Write a scalar UDF ufn_CustomerOrderCount(@CustomerID) that returns the total number of orders placed by a specific customer.
create function sales.ufn_CustomerOrderCount (@CustomerID INT)
returns Int
as begin
	Declare @total_orders Int
	select @total_orders = count(customer_id) from sales.orders where customer_id = @CustomerID
	return isnull(@total_orders,0)
End;

select sales.ufn_CustomerOrderCount(14) as total_orders
-- Create a scalar UDF ufn_CategoryRevenue(@CategoryID, @Year) that calculates the total revenue (sum of quantity * (list_price - discount)) for all products in a specific category during a given year. The function should return 0 if no sales exist.
create function sales.ufn_CategoryRevenue (@CategoryID INT, @Year int)
returns Decimal (15,2)
as begin
	
	declare @total_rev decimal (15,2)
	select @total_rev = sum(o.quantity * (o.list_price -(o.list_price*o.discount)))
	from sales.order_items o
	join production.products p
	on o.product_id = p.product_id
	join sales.orders r
	on o.order_id = r.order_id
	join production.categories c
	on c.category_id = p.category_id
	where c.category_id = @CategoryID and year(r.order_date) = @Year

	return isnull(@total_rev,0)
end;

select sales.ufn_CategoryRevenue (2,2018) as total_rev


 -- Design a scalar UDF ufn_StaffSalesTotal(@StaffID, @Year) that returns the total sales amount (after discounts) generated by a staff member in a specific year.
 create function sales.ufn_StaffSalesTotal(@StaffID INT, @Year INT)
 returns Decimal(15,2)
 as begin

	declare @total_sales decimal(15,2)
	select @total_sales =  sum(i.quantity * (i.list_price -(i.list_price*i.discount))) 
							from sales.staffs s
							join sales.orders o
							on s.staff_id = o.staff_id
							join sales.order_items i
							on o.order_id = i.order_id
							where s.staff_id = @StaffID and year(o.order_date) = @Year

	return isnull(@total_sales,0)
End;
select sales.ufn_StaffSalesTotal(3,2018) as total_sales;

-- Q6: For each order, calculate its total amount and then categorize it as ‘Low’, ‘Medium’ or ‘High’ value using thresholds of your choice.

-- Q7: Identify a query that filters orders by order date and customer city. Then describe what non-clustered index you’d create to optimize it.

-- Q8: Retrieve all products whose list price exceeds the average list price of their category.

-- Q9: Write a T-SQL script that takes a @StoreID parameter: if that store has processed zero orders in the last 30 days, print “No recent sales”; otherwise print “Active store”.

-- Q10: Produce a single list of all distinct “locations” where the business operates, combining store cities and customer cities, with a column labeling each row as ‘Store’ or ‘Customer’.

-- Q11: List every order, showing its ID, date, customer name, store city and country, plus for each order line the product name and quantity—include orders even if they have no items yet.

-- Q12: Write a trigger on stocks that prevents any update setting quantity to a negative number—if attempted, roll back the operation.

-- Q13: Design a stored procedure usp_GetCustomerOrders that takes @CustomerID and returns all their orders with totals and status.

-- Q14: Create an AFTER INSERT trigger on order_items that updates a running total in a separate product_sales_summary table.

-- Q15: Create a table-valued UDF ufn_ProductsByCategory(@CategoryID) listing all products in a category along with their current total stock across all stores.

-- Q16: Propose an index strategy to speed up retrieving the top-selling products in a given month.

-- Q17: Build a proc usp_AdjustStock that accepts @StoreID, @ProductID, and @AdjustmentQty; it should apply the change and log it into an inventory_log table.

-- Q18: For each store, show its name and the number of orders it processed that exceeded that store’s own average order total.

-- Q19: List every product and assign a stock-status label—‘Out of Stock’, ‘Low Stock’ (<10 units), or ‘In Stock’—based on its total quantity across all stores.

-- Q20: Create a view showing each customer’s total lifetime spend and most recent order date.
