use BikeStores

-- Q1: Create a view that returns each product’s total sold quantity and average discount received.
create view production.product_quantity_solds
as
	select p.product_name, sum(o.quantity) as total_quantity_sold, avg(o.discount) as avg_discount 
	from production.products p
	left join sales.order_items o
	on p.product_id = o.product_id
	group by p.product_name;

select * from production.product_quantity_solds
order by total_quantity_sold;

-- Q2: List customers who have placed more orders than the average number of orders per customer.
select * from sales.customer_orders
where total_price > (select avg(total_price) from sales.customer_orders)
order by total_price desc;

-- Q3: Build an IF…ELSE block that accepts @BrandID and prints the number of products under that brand, or “Brand not found” if none exist.
create procedure production.brand_check @brandID int
as
begin
if exists (select 1 from production.brands where brand_id = @brandID)
begin
		select b.brand_name, COUNT(p.product_id)
		from production.products p
		join production.brands b
		on p.brand_id = b.brand_id
		where b.brand_id = @brandID
		group by b.brand_name
End
else
begin
	print 'Brand ID not found.'
end
end;

exec production.brand_check @brandID = 112;


select * from production.brands;
select * from production.products;

-- Q4: Find all pairs of products that share the same brand but belong to different categories; show both product names, their categories, and the brand name.
select p.product_name, c.category_name, b.brand_name 
from production.categories c
join production.products p
on c.category_id = p.category_id
join production.brands b
on p.brand_id = b.brand_id
order by b.brand_id;

-- Q5: Write a scalar UDF ufn_CalcOrderTotal(@OrderID) returning the total amount (after discount) for that order.
create function sales.ufn_CalcOrderTotal (@orderID int)
returns Decimal(10,2) as
begin
	Declare @total Decimal (10,2)
	select @total = sum(quantity * (list_price -(list_price*discount)))
	from sales.order_items
	where order_id = @orderID
	Return ISNULL(@total, 0)
End;


select sales.ufn_calcordertotal(1) as total_order

-- Write a scalar UDF ufn_CustomerOrderCount(@CustomerID) that returns the total number of orders placed by a specific customer.
create function sales.ufn_CustomerOrderCount (@CustomerID INT)
returns Int
as begin
	Declare @total_orders Int
	select @total_orders = count(customer_id) from sales.orders where customer_id = @CustomerID
	return isnull(@total_orders,0)
End;

select sales.ufn_CustomerOrderCount(14) as total_orders
-- Create a scalar UDF ufn_CategoryRevenue(@CategoryID, @Year) that calculates the total revenue (sum of quantity * (list_price - discount)) for all products in a specific category during a given year. The function should return 0 if no sales exist.
create function sales.ufn_CategoryRevenue (@CategoryID INT, @Year int)
returns Decimal (15,2)
as begin
	
	declare @total_rev decimal (15,2)
	select @total_rev = sum(o.quantity * (o.list_price -(o.list_price*o.discount)))
	from sales.order_items o
	join production.products p
	on o.product_id = p.product_id
	join sales.orders r
	on o.order_id = r.order_id
	join production.categories c
	on c.category_id = p.category_id
	where c.category_id = @CategoryID and year(r.order_date) = @Year

	return isnull(@total_rev,0)
end;

select sales.ufn_CategoryRevenue (2,2018) as total_rev


 -- Design a scalar UDF ufn_StaffSalesTotal(@StaffID, @Year) that returns the total sales amount (after discounts) generated by a staff member in a specific year.
 create function sales.ufn_StaffSalesTotal(@StaffID INT, @Year INT)
 returns Decimal(15,2)
 as begin

	declare @total_sales decimal(15,2)
	select @total_sales =  sum(i.quantity * (i.list_price -(i.list_price*i.discount))) 
							from sales.staffs s
							join sales.orders o
							on s.staff_id = o.staff_id
							join sales.order_items i
							on o.order_id = i.order_id
							where s.staff_id = @StaffID and year(o.order_date) = @Year

	return isnull(@total_sales,0)
End;
select sales.ufn_StaffSalesTotal(3,2018) as total_sales;

-- Q6: For each order, calculate its total amount and then categorize it as ‘Low’, ‘Medium’ or ‘High’ value using thresholds of your choice.
select order_id,  sum(i.quantity * (i.list_price -(i.list_price*i.discount))) as total_amount,

	case
		when sum(i.quantity * (i.list_price -(i.list_price*i.discount))) >= 9000 then 'High'
		when sum(i.quantity * (i.list_price -(i.list_price*i.discount))) > 5000 then 'Medium'
		when sum(i.quantity * (i.list_price -(i.list_price*i.discount))) < 5000 then 'Low'
	end as status

from sales.order_items i
group by order_id;

-- Q8: Retrieve all products whose list price exceeds the average list price of their category.
SELECT 
    p.product_id,
    p.product_name,
    p.list_price,
    c.category_name
FROM production.products p
JOIN production.categories c ON p.category_id = c.category_id
WHERE p.list_price > (
    SELECT AVG(p2.list_price)
    FROM production.products p2
    WHERE p2.category_id = p.category_id
);


-- Q10: Produce a single list of all distinct “locations” where the business operates, combining store cities and customer cities, with a column labeling each row as ‘Store’ or ‘Customer’.
select distinct city as location, 'customer' as type
from sales.customers

union

select distinct city as location, 'store' as type
from sales.stores;

-- Q13: Design a stored procedure usp_GetCustomerOrders that takes @CustomerID and returns all their orders with totals and status.
create procedure sales.usp_GetCustomerOrders (@CustomerID Int)
as begin
	select c.first_name, sum(i.quantity * (i.list_price -(i.list_price*i.discount))) as total, o.order_status
	from sales.customers c
	join sales.orders o
	on c.customer_id = o.customer_id
	join sales.order_items i
	on o.order_id = i.order_id
	where c.customer_id = @CustomerID
	group by c.first_name, order_status
	order by c.first_name
end;

exec sales.usp_GetCustomerOrders 11;

-- Q14: Create an AFTER INSERT trigger on order_items that updates a running total in a separate product_sales_summary table.

-- Q15: Create a table-valued UDF ufn_ProductsByCategory(@CategoryID) listing all products in a category along with their current total stock across all stores.

-- Q16: Propose an index strategy to speed up retrieving the top-selling products in a given month.

-- Q17: Build a proc usp_AdjustStock that accepts @StoreID, @ProductID, and @AdjustmentQty; it should apply the change and log it into an inventory_log table.

-- Q18: For each store, show its name and the number of orders it processed that exceeded that store’s own average order total.

-- Q19: List every product and assign a stock-status label—‘Out of Stock’, ‘Low Stock’ (<10 units), or ‘In Stock’—based on its total quantity across all stores.

-- Q20: Create a view showing each customer’s total lifetime spend and most recent order date.
